# Warlock Simulator Project Plan
## Subset of WoWSims for Custom Private Server

---

## Project Overview

**Goal:** Create a standalone Warlock simulator that:
- Uses core WoWSims simulation engine
- Supports custom "Mystic Enchants" (server-specific mechanics)
- Uses YAML configuration instead of web UI
- Implements APL (Action Priority List) system for rotations
- Outputs DPS and combat metrics

**Estimated Timeline:** 2-4 weeks for working prototype

---

## Architecture Overview

```
┌─────────────────────────────────────────────┐
│         Your Warlock Sim (Standalone)       │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────┐      ┌─────────────────┐ │
│  │ character.   │      │ rotation.yml    │ │
│  │ yml          │      │ (Human-readable)│ │
│  │              │      │                 │ │
│  │ - Stats      │      │ - IF backdraft  │ │
│  │ - Talents    │      │   CAST chaos    │ │
│  │ - Glyphs     │      │ - IF no_dots    │ │
│  │ - Mystic     │      │   CAST immolate │ │
│  │   Enchants   │      └─────────────────┘ │
│  └──────────────┘               │          │
│         │                       │          │
│         │                       ▼          │
│         │              ┌─────────────────┐ │
│         └─────────────►│ APL Compiler    │ │
│                        │ (YAML→Proto)    │ │
│                        └─────────────────┘ │
│                               │            │
│                               ▼            │
│  ┌─────────────────────────────────────┐  │
│  │   WoWSims Core Engine (Reused!)     │  │
│  │   - sim.Step()                      │  │
│  │   - APL execution                   │  │
│  │   - Event system                    │  │
│  └─────────────────────────────────────┘  │
│                               │            │
│                               ▼            │
│  ┌─────────────────────────────────────┐  │
│  │   spells.yml (Warlock spells only)  │  │
│  │   - Chaos Bolt: dmg=1300, coef=0.71│  │
│  │   - Immolate: dot_dmg=775, ...     │  │
│  └─────────────────────────────────────┘  │
│                               │            │
│                               ▼            │
│  ┌─────────────────────────────────────┐  │
│  │   mystic_enchants.yml               │  │
│  │   - backdraft_chaos_bolt:           │  │
│  │     on_cast: add_aura(...)          │  │
│  └─────────────────────────────────────┘  │
│                                             │
└─────────────────────────────────────────────┘
                    │
                    ▼
            ┌───────────────┐
            │  Results JSON │
            │  - DPS: 8432  │
            │  - Cast count │
            └───────────────┘
```

---

## Protocol Buffers Strategy

### Understanding the Issue

WoWSims uses Protocol Buffers (protobufs) extensively, especially for the APL system. Protobufs are Google's way of defining data structures that work across multiple languages.

**Example:**
```protobuf
// proto/apl.proto
message APLAction {
  oneof action {
    APLActionCastSpell cast_spell = 1;
    APLActionChannelSpell channel_spell = 2;
    APLActionWait wait = 3;
  }
  APLValue condition = 20;
}
```

This generates Go code that the APL system uses:
```go
func (rot *APLRotation) newAPLAction(config *proto.APLAction) *APLAction {
    switch config.Action.(type) {
    case *proto.APLAction_CastSpell:
        return rot.newActionCastSpell(config.GetCastSpell())
    }
}
```

### Option 1: Keep Protobufs (Easiest)

**What:** Copy the entire proto infrastructure from WoWSims

**Structure:**
```
warlock-sim/
├── proto/
│   ├── common.proto
│   ├── api.proto
│   ├── apl.proto          ← All the APL definitions
│   └── warlock.proto
├── sim/core/proto/        ← Generated .pb.go files
│   ├── api.pb.go
│   ├── apl.pb.go
│   └── common.pb.go
```

**Setup Commands:**
```bash
# One-time setup
brew install protobuf  # macOS
# OR
apt-get install protobuf-compiler  # Linux

go install google.golang.org/protobuf/cmd/protoc-gen-go@latest

# Whenever you change .proto files
protoc --go_out=. proto/*.proto
```

**Pros:**
- ✅ Reuse ALL WoWSims APL code without changes
- ✅ APL compiler already works perfectly
- ✅ Fast to get running
- ✅ Type-safe data structures

**Cons:**
- ❌ Need to install protoc compiler
- ❌ Extra build step when modifying protos
- ❌ More dependencies in go.mod
- ❌ Learning curve for proto syntax

**Best For:** Quick start, minimal code changes

---

### Option 2: "Vendor" Protobufs (Recommended) ⭐

**What:** Copy only the **generated** `.pb.go` files (not the `.proto` source files)

**Structure:**
```
warlock-sim/
├── vendor/
│   └── proto/             ← Just copy the .pb.go files
│       ├── api.pb.go      ← Already generated by WoWSims
│       ├── apl.pb.go
│       └── common.pb.go
```

**Setup Commands:**
```bash
# 1. Clone WoWSims
git clone https://github.com/wowsims/wotlk.git

# 2. Copy just the generated proto files
mkdir -p warlock-sim/proto
cp wotlk/sim/core/proto/*.pb.go warlock-sim/proto/

# 3. Update import paths in copied files
# Change: "github.com/wowsims/wotlk/sim/core/proto"
# To: "warlock-sim/proto"

# 4. Done! Just run:
go run main.go
```

**go.mod looks like:**
```go
module warlock-sim

go 1.21

require (
    google.golang.org/protobuf v1.31.0  // Just for runtime, not compiler
)
```

**Pros:**
- ✅ No protoc compiler needed
- ✅ No build step required
- ✅ Still use full APL system
- ✅ Just `go run main.go` works immediately
- ✅ Easier onboarding for contributors

**Cons:**
- ❌ If you want to modify proto definitions, need protoc
- ❌ Slightly larger git repo (~500KB of generated code)
- ❌ Need to manually sync if WoWSims updates protos

**Best For:** Getting started quickly, avoiding build complexity

---

### Option 3: Ditch Protobufs (Most Work)

**What:** Rewrite APL system to use plain Go structs

**Before (with proto):**
```go
func (rot *APLRotation) newAPLAction(config *proto.APLAction) *APLAction {
    switch config.Action.(type) {
    case *proto.APLAction_CastSpell:
        return rot.newActionCastSpell(config.GetCastSpell())
    case *proto.APLAction_ChannelSpell:
        return rot.newActionChannelSpell(config.GetChannelSpell())
    }
}
```

**After (plain Go):**
```go
type APLAction struct {
    Type      string  // "cast_spell", "channel", "wait"
    SpellID   int32
    Condition *APLCondition
}

type APLCondition struct {
    Type  string  // "aura_active", "dot_remaining", "compare"
    Value interface{}
}

func (rot *APLRotation) newAPLAction(config APLAction) *APLAction {
    switch config.Type {
    case "cast_spell":
        return rot.newActionCastSpell(config.SpellID)
    case "channel":
        return rot.newActionChannelSpell(config.SpellID)
    }
}
```

**Pros:**
- ✅ No protobuf dependency at all
- ✅ Simpler dependency stack
- ✅ Easy to understand for contributors
- ✅ Complete control over data structures
- ✅ Easier to debug (plain Go)

**Cons:**
- ❌ Rewrite ~2000 lines of APL code
- ❌ Lose compile-time type safety from protobufs
- ❌ Need to reimplement APL value system
- ❌ 1-2 weeks of extra development time
- ❌ Potential bugs from reimplementation

**Best For:** Long-term maintainability, if you plan major APL changes

---

### Recommendation: Start with Option 2 (Vendor)

**Phase 1:** Vendor the proto files
- Get up and running in hours, not days
- No tooling setup needed
- Full APL system works immediately

**Phase 2+:** Add YAML layer on top
- Your human-friendly YAML compiles to proto structs
- Existing APL engine handles execution
- Best of both worlds

**Later (optional):** Migrate to Option 3 if needed
- Once you understand the system deeply
- If you need extensive APL customization
- After the core sim is working

---

## Development Plan

### Phase 1: Minimal Working Sim (Week 1)

**Goal:** Run a single hardcoded rotation and get DPS output

#### Tasks:

**1.1: Extract Core Files from WoWSims**

Files to copy:
```
wotlk/sim/core/sim.go           → warlock-sim/core/sim.go
wotlk/sim/core/spell.go         → warlock-sim/core/spell.go
wotlk/sim/core/character.go     → warlock-sim/core/character.go
wotlk/sim/core/aura.go          → warlock-sim/core/aura.go
wotlk/sim/core/stats.go         → warlock-sim/core/stats.go
wotlk/sim/core/dot.go           → warlock-sim/core/dot.go
wotlk/sim/core/pending_action.go → warlock-sim/core/pending_action.go
wotlk/sim/core/unit.go          → warlock-sim/core/unit.go
wotlk/sim/core/environment.go   → warlock-sim/core/environment.go
wotlk/sim/core/proto/*.pb.go    → warlock-sim/proto/*.pb.go (Option 2)
```

**1.2: Create Basic Warlock Structure**

```go
// warlock/warlock.go
package warlock

import (
    "time"
    "warlock-sim/core"
)

type Warlock struct {
    *core.Character
    
    // Spells
    ChaosBolt    *core.Spell
    Immolate     *core.Spell
    Conflagrate  *core.Spell
    Incinerate   *core.Spell
    
    // Talents
    Talents WarlockTalents
}

type WarlockTalents struct {
    Bane             int32
    Aftermath        int32
    MoltenCore       int32
    Backlash         int32
    ChaosBolt        int32
    FireAndBrimstone int32
    Backdraft        int32
}

func New(char *core.Character) *Warlock {
    warlock := &Warlock{
        Character: char,
    }
    
    warlock.registerSpells()
    
    return warlock
}

func (warlock *Warlock) registerSpells() {
    warlock.registerChaosBolt()
    warlock.registerImmolate()
    warlock.registerConflagrate()
    warlock.registerIncinerate()
}
```

**1.3: Implement 3-5 Basic Spells**

```go
// warlock/chaos_bolt.go
package warlock

import (
    "time"
    "warlock-sim/core"
)

func (warlock *Warlock) registerChaosBolt() {
    warlock.ChaosBolt = warlock.RegisterSpell(core.SpellConfig{
        ActionID: core.ActionID{SpellID: 50796},
        SpellSchool: core.SpellSchoolFire,
        ProcMask: core.ProcMaskSpellDamage,
        Flags: core.SpellFlagAPL,
        
        ManaCost: core.ManaCostOptions{
            BaseCost: 0.07, // 7% base mana
        },
        
        Cast: core.CastConfig{
            DefaultCast: core.Cast{
                GCD: core.GCDDefault,
                CastTime: time.Millisecond * 2500,
            },
        },
        
        DamageMultiplier: 1.0,
        CritMultiplier: 1.5,
        ThreatMultiplier: 1.0,
        
        ApplyEffects: func(sim *core.Simulation, target *core.Unit, spell *core.Spell) {
            baseDamage := 1429 + 0.71 * spell.SpellPower()
            
            // Apply talent modifiers
            baseDamage *= 1.0 + 0.04 * float64(warlock.Talents.FireAndBrimstone)
            
            spell.CalcAndDealDamage(sim, target, baseDamage, spell.OutcomeMagicHitAndCrit)
        },
    })
}
```

```go
// warlock/immolate.go
package warlock

import (
    "time"
    "warlock-sim/core"
)

func (warlock *Warlock) registerImmolate() {
    warlock.Immolate = warlock.RegisterSpell(core.SpellConfig{
        ActionID: core.ActionID{SpellID: 47811},
        SpellSchool: core.SpellSchoolFire,
        ProcMask: core.ProcMaskSpellDamage,
        Flags: core.SpellFlagAPL,
        
        ManaCost: core.ManaCostOptions{
            BaseCost: 0.17,
        },
        
        Cast: core.CastConfig{
            DefaultCast: core.Cast{
                GCD: core.GCDDefault,
                CastTime: time.Millisecond * 2000,
            },
        },
        
        Dot: core.DotConfig{
            Aura: core.Aura{
                Label: "Immolate",
            },
            NumberOfTicks: 5,
            TickLength: time.Second * 3,
            OnSnapshot: func(sim *core.Simulation, target *core.Unit, dot *core.Dot, isRollover bool) {
                // Direct damage on cast
                directDamage := 460 + 0.20 * dot.Spell.SpellPower()
                dot.SnapshotBaseDamage = directDamage
                
                // DOT damage
                dotDamage := 775 + 0.20 * dot.Spell.SpellPower()
                dot.SnapshotBaseDamage = dotDamage / 5 // Per tick
            },
            OnTick: func(sim *core.Simulation, target *core.Unit, dot *core.Dot) {
                dot.CalcAndDealPeriodicSnapshotDamage(sim, target, dot.OutcomeTick)
            },
        },
        
        DamageMultiplier: 1.0,
        CritMultiplier: 1.5,
        ThreatMultiplier: 1.0,
        
        ApplyEffects: func(sim *core.Simulation, target *core.Unit, spell *core.Spell) {
            // Apply direct damage
            result := spell.CalcDamage(sim, target, spell.Dot(target).SnapshotBaseDamage, spell.OutcomeMagicHitAndCrit)
            spell.DealDamage(sim, result)
            
            // Apply DOT
            if result.Landed() {
                spell.Dot(target).Apply(sim)
            }
        },
    })
}
```

**1.4: Create Simple Hardcoded Rotation**

```go
// warlock/rotation.go
package warlock

func (warlock *Warlock) OnGCDReady(sim *core.Simulation) {
    target := warlock.CurrentTarget
    
    // Simple priority:
    // 1. Immolate if not up
    // 2. Conflagrate if ready
    // 3. Chaos Bolt
    
    if !warlock.Immolate.Dot(target).IsActive() {
        if warlock.Immolate.Cast(sim, target) {
            return
        }
    }
    
    if warlock.Conflagrate.IsReady(sim) {
        if warlock.Conflagrate.Cast(sim, target) {
            return
        }
    }
    
    if warlock.ChaosBolt.Cast(sim, target) {
        return
    }
}
```

**1.5: Create Main Entry Point**

```go
// main.go
package main

import (
    "fmt"
    "time"
    "warlock-sim/core"
    "warlock-sim/warlock"
)

func main() {
    // Create simulation request
    rsr := &core.RaidSimRequest{
        Raid: &core.Raid{
            Parties: []*core.Party{
                {
                    Players: []*core.Player{
                        {
                            Name: "TestWarlock",
                            Race: core.RaceUndead,
                            Class: core.ClassWarlock,
                            Equipment: createTestGear(),
                        },
                    },
                },
            },
        },
        Encounter: &core.Encounter{
            Duration: time.Minute * 5,
        },
        SimOptions: &core.SimOptions{
            Iterations: 1000,
        },
    }
    
    // Run simulation
    result := core.RunSim(rsr, nil)
    
    // Print results
    fmt.Printf("DPS: %.1f\n", result.RaidMetrics.Dps.Avg)
    fmt.Printf("Total Damage: %.0f\n", result.RaidMetrics.Dps.Avg * 300) // 5 min fight
}

func createTestGear() *core.EquipmentSpec {
    return &core.EquipmentSpec{
        // Hardcoded stats for testing
    }
}
```

**1.6: Run and Verify**

```bash
go mod init warlock-sim
go mod tidy
go run main.go

# Expected output:
# DPS: 3521.4
# Total Damage: 1056420
```

#### Deliverable:
Working sim that casts spells in a simple rotation and outputs DPS

---

### Phase 2: YAML Configuration (Week 2)

**Goal:** Move hardcoded data to config files

#### 2.1: Character Configuration

```yaml
# config/character.yml
name: "MyWarlock"
level: 80
race: "undead"

stats:
  spell_power: 2800
  crit_rating: 850
  haste_rating: 650
  hit_rating: 446
  intellect: 1200
  stamina: 1500
  spirit: 800

talents:
  # Destruction tree
  bane: 5
  aftermath: 2
  molten_core: 3
  backlash: 3
  conflagrate: 1
  chaos_bolt: 1
  fire_and_brimstone: 5
  backdraft: 3
  emberstorm: 5
  backlash: 3
  
  # Demonology tree
  demonic_embrace: 3
  
  # Affliction tree
  suppression: 3

glyphs:
  major:
    - conflagrate
    - chaos_bolt
    - immolate
  minor:
    - drain_soul
    - unending_breath
    - souls

mystic_enchants:
  - backdraft_chaos_bolt
  - immolate_haste_scaling
```

#### 2.2: Spell Database

```yaml
# config/spells.yml
spells:
  - id: 50796
    name: "Chaos Bolt"
    rank: 4
    school: "fire"
    gcd: 1500ms
    cast_time: 2500ms
    mana_cost_pct: 0.07
    base_damage: 1429
    sp_coefficient: 0.71
    can_crit: true
    crit_multiplier: 1.5
    flags: 
      - ignore_armor
      - apl_castable
    
  - id: 47811
    name: "Immolate"
    rank: 11
    school: "fire"
    gcd: 1500ms
    cast_time: 2000ms
    mana_cost_pct: 0.17
    
    direct_damage: 460
    direct_sp_coef: 0.20
    
    dot_duration: 15s
    dot_damage: 775
    dot_sp_coef: 0.20
    dot_tick_rate: 3s
    dot_num_ticks: 5
    
    flags:
      - dot
      - apl_castable
      
  - id: 17962
    name: "Conflagrate"
    rank: 8
    school: "fire"
    gcd: 1500ms
    cast_time: 0ms  # Instant
    cooldown: 10s
    mana_cost_pct: 0.16
    base_damage: 1582
    sp_coefficient: 0.60
    
    requires_immolate: true
    consumes_immolate: false
    
    flags:
      - apl_castable
      
  - id: 47838
    name: "Incinerate"
    rank: 4
    school: "fire"
    gcd: 1500ms
    cast_time: 2500ms
    mana_cost_pct: 0.14
    base_damage: 582
    sp_coefficient: 0.714
    
    # Bonus damage if Immolate is on target
    immolate_bonus_pct: 0.05
    
    flags:
      - apl_castable

auras:
  - id: 54274
    name: "Backdraft"
    duration: 15s
    max_stacks: 3
    proc_chance: 1.0
    
    triggered_by:
      - conflagrate
      
    effects:
      - type: "cast_speed"
        spells: [incinerate, chaos_bolt, soul_fire]
        value: 0.30  # 30% faster cast
        
  - id: 63167
    name: "Decimation"
    duration: 10s
    max_stacks: 1
    proc_chance: 1.0
    
    triggered_when:
      - target_health_below: 0.35
      
    effects:
      - type: "cast_speed"
        spells: [soul_fire]
        value: 1.0  # Makes Soul Fire instant
      - type: "cost_reduction"
        spells: [soul_fire]
        value: 1.0  # Free cast
```

#### 2.3: Loader Implementation

```go
// loader/character.go
package loader

import (
    "os"
    "gopkg.in/yaml.v3"
)

type CharacterConfig struct {
    Name            string
    Level           int
    Race            string
    Stats           map[string]float64
    Talents         map[string]int
    Glyphs          GlyphConfig
    MysticEnchants  []string
}

type GlyphConfig struct {
    Major []string
    Minor []string
}

func LoadCharacter(path string) (*CharacterConfig, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var cfg CharacterConfig
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, err
    }
    
    return &cfg, nil
}
```

```go
// loader/spells.go
package loader

type SpellDatabase struct {
    Spells []SpellConfig
    Auras  []AuraConfig
}

type SpellConfig struct {
    ID              int32
    Name            string
    Rank            int
    School          string
    GCD             string
    CastTime        string
    Cooldown        string
    ManaCostPct     float64
    BaseDamage      float64
    SPCoefficient   float64
    CanCrit         bool
    CritMultiplier  float64
    
    // DOT fields
    DotDuration     string
    DotDamage       float64
    DotSPCoef       float64
    DotTickRate     string
    
    Flags           []string
}

func LoadSpells(path string) (*SpellDatabase, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var db SpellDatabase
    if err := yaml.Unmarshal(data, &db); err != nil {
        return nil, err
    }
    
    return &db, nil
}
```

#### 2.4: Update Main to Use Config

```go
// main.go
package main

import (
    "fmt"
    "flag"
    "warlock-sim/loader"
    "warlock-sim/warlock"
    "warlock-sim/core"
)

func main() {
    charPath := flag.String("character", "config/character.yml", "Path to character config")
    spellPath := flag.String("spells", "config/spells.yml", "Path to spell database")
    iterations := flag.Int("iterations", 10000, "Number of iterations")
    flag.Parse()
    
    // Load configuration
    charCfg, err := loader.LoadCharacter(*charPath)
    if err != nil {
        panic(err)
    }
    
    spellDB, err := loader.LoadSpells(*spellPath)
    if err != nil {
        panic(err)
    }
    
    // Create warlock from config
    warlock := warlock.NewFromConfig(charCfg, spellDB)
    
    // Run simulation
    result := runSim(warlock, *iterations)
    
    // Print results
    printResults(result)
}
```

#### Deliverable:
Sim reads character stats, talents, and spell definitions from YAML files

---

### Phase 3: Human-Readable APL (Week 3)

**Goal:** Write rotations in friendly YAML format, compile to proto JSON

#### 3.1: YAML APL Format

```yaml
# config/rotation.yml
name: "Destruction Single Target"

prepull:
  - at: -3.5s
    cast: soul_fire
    comment: "Pre-cast Soul Fire with Soul Shards"
    
  - at: -1.0s
    use: potion_of_speed
    
  - at: -0.5s
    cast: immolate

rotation:
  - name: "Backdraft Chaos Bolt"
    if:
      all:
        - aura.backdraft.active
        - aura.backdraft.stacks >= 2
        - spell.chaos_bolt.ready
        - not: spell.conflagrate.ready  # Save for Backdraft refresh
    then: cast chaos_bolt
    comment: "Use Chaos Bolt with 2+ Backdraft stacks"
    
  - name: "Maintain Immolate"
    if:
      any:
        - not: dot.immolate.active
        - dot.immolate.remaining < 3s
    then: cast immolate
    comment: "Keep Immolate up at all times"
    
  - name: "Conflagrate on CD"
    if: spell.conflagrate.ready
    then: cast conflagrate
    comment: "Conflagrate generates Backdraft stacks"
    
  - name: "Chaos Bolt"
    if:
      all:
        - spell.chaos_bolt.ready
        - mana.percent > 10
        - or:
          - not: aura.backdraft.active
          - dot.immolate.remaining > 6s  # Don't clip Immolate refresh
    then: cast chaos_bolt
    comment: "Main nuke"
    
  - name: "Incinerate with Backdraft"
    if:
      all:
        - aura.backdraft.active
        - aura.backdraft.stacks >= 1
    then: cast incinerate
    comment: "Backdraft buffed Incinerate"
    
  - name: "Incinerate Filler"
    then: cast incinerate
    comment: "Default filler spell"
    
  - name: "Life Tap"
    if:
      all:
        - mana.percent < 30
        - health.percent > 50
    then: cast life_tap
    comment: "Emergency mana management"
```

#### 3.2: APL Compiler

```go
// apl/compiler.go
package apl

import (
    "fmt"
    "time"
    "gopkg.in/yaml.v3"
    "warlock-sim/proto"
)

type YAMLRotation struct {
    Name     string
    Prepull  []YAMLPrepullAction
    Rotation []YAMLAction
}

type YAMLAction struct {
    Name    string
    If      YAMLCondition
    Then    YAMLThen
    Comment string
}

type YAMLCondition struct {
    All []interface{}
    Any []interface{}
    Not interface{}
    
    // Direct conditions
    AuraActive    string `yaml:"aura.active"`
    DotActive     string `yaml:"dot.active"`
    SpellReady    string `yaml:"spell.ready"`
    ManaPercent   string `yaml:"mana.percent"`
}

type YAMLThen struct {
    Cast string
    Use  string
    Wait string
}

func CompileYAML(yamlPath string) (*proto.APLRotation, error) {
    data, err := os.ReadFile(yamlPath)
    if err != nil {
        return nil, err
    }
    
    var yamlRot YAMLRotation
    if err := yaml.Unmarshal(data, &yamlRot); err != nil {
        return nil, err
    }
    
    protoRot := &proto.APLRotation{
        Type: proto.APLRotation_TypeAPL,
        PriorityList: []*proto.APLListItem{},
    }
    
    // Compile each action
    for _, action := range yamlRot.Rotation {
        protoAction, err := compileAction(action)
        if err != nil {
            return nil, fmt.Errorf("compiling action '%s': %w", action.Name, err)
        }
        protoRot.PriorityList = append(protoRot.PriorityList, protoAction)
    }
    
    return protoRot, nil
}

func compileAction(action YAMLAction) (*proto.APLListItem, error) {
    item := &proto.APLListItem{
        Action: &proto.APLAction{},
    }
    
    // Compile condition
    if !isEmptyCondition(action.If) {
        condition, err := compileCondition(action.If)
        if err != nil {
            return nil, err
        }
        item.Action.Condition = condition
    }
    
    // Compile action
    if action.Then.Cast != "" {
        spellID := getSpellIDByName(action.Then.Cast)
        item.Action.Action = &proto.APLAction_CastSpell{
            CastSpell: &proto.APLActionCastSpell{
                SpellId: &proto.ActionID{
                    SpellId: spellID,
                },
            },
        }
    }
    
    return item, nil
}

func compileCondition(cond YAMLCondition) (*proto.APLValue, error) {
    // Handle "all" (AND)
    if len(cond.All) > 0 {
        andVal := &proto.APLValue{
            Value: &proto.APLValue_And{
                And: &proto.APLValueAnd{
                    Vals: []*proto.APLValue{},
                },
            },
        }
        
        for _, subCond := range cond.All {
            subVal, err := compileSubCondition(subCond)
            if err != nil {
                return nil, err
            }
            andVal.GetAnd().Vals = append(andVal.GetAnd().Vals, subVal)
        }
        
        return andVal, nil
    }
    
    // Handle "any" (OR)
    if len(cond.Any) > 0 {
        // Similar to AND...
    }
    
    // Handle "not"
    if cond.Not != nil {
        // ...
    }
    
    // Handle direct conditions
    return compileDirectCondition(cond)
}

func compileDirectCondition(cond YAMLCondition) (*proto.APLValue, error) {
    // Parse "aura.backdraft.active"
    if cond.AuraActive != "" {
        parts := strings.Split(cond.AuraActive, ".")
        auraName := parts[1] // "backdraft"
        
        return &proto.APLValue{
            Value: &proto.APLValue_AuraIsActive{
                AuraIsActive: &proto.APLValueAuraIsActive{
                    AuraId: &proto.ActionID{
                        SpellId: getAuraIDByName(auraName),
                    },
                },
            },
        }, nil
    }
    
    // Parse "dot.immolate.remaining < 3s"
    if cond.DotRemaining != "" {
        // ... parse comparison operator
    }
    
    return nil, fmt.Errorf("unknown condition type")
}
```

#### 3.3: Integration

```go
// main.go (updated)
func main() {
    charPath := flag.String("character", "config/character.yml", "Character config")
    rotPath := flag.String("rotation", "config/rotation.yml", "Rotation APL")
    iterations := flag.Int("iterations", 10000, "Iterations")
    flag.Parse()
    
    // Load configs
    charCfg, _ := loader.LoadCharacter(*charPath)
    
    // Compile APL from YAML
    aplProto, err := apl.CompileYAML(*rotPath)
    if err != nil {
        panic(fmt.Errorf("APL compilation failed: %w", err))
    }
    
    // Create warlock with compiled APL
    warlock := warlock.NewFromConfig(charCfg)
    warlock.SetRotation(aplProto)
    
    // Run sim
    result := runSim(warlock, *iterations)
    printResults(result)
}
```

#### Deliverable:
Write rotations in human-readable YAML, automatically compile to working APL

---

### Phase 4: Mystic Enchants (Week 4)

**Goal:** Implement custom server mechanics

#### 4.1: Mystic Enchant Definition

```yaml
# config/mystic_enchants.yml
enchants:
  - id: "backdraft_chaos_bolt"
    name: "Improved Backdraft"
    slot: "mystic_head"
    description: "When you cast Chaos Bolt during Backdraft, spells don't consume Backdraft charges for 4 seconds"
    
    trigger:
      on_spell_cast: chaos_bolt
      conditions:
        - aura.backdraft.active
        
    effects:
      - type: "add_aura"
        aura:
          id: "backdraft_preservation"
          duration: 4s
          effects:
            - type: "modify_aura"
              target_aura: backdraft
              change: "prevent_stack_consumption"
              
  - id: "immolate_haste_scaling"
    name: "Hastened Flames"
    slot: "mystic_chest"
    description: "Immolate DOT ticks are affected by haste (normally they aren't)"
    
    modify_spell: immolate
    changes:
      - property: "dot_uses_haste"
        value: true
        
  - id: "conflag_no_consume"
    name: "Eternal Conflagration"
    slot: "mystic_hands"
    description: "Conflagrate no longer consumes Immolate"
    
    modify_spell: conflagrate
    changes:
      - property: "consumes_immolate"
        value: false
        
  - id: "corruption_stacking"
    name: "Compounding Corruption"
    slot: "mystic_legs"
    description: "Corruption can stack up to 3 times"
    
    modify_spell: corruption
    changes:
      - property: "dot_max_stacks"
        value: 3
      - property: "dot_refresh_behavior"
        value: "pandemic"  # New casts extend duration
```

#### 4.2: Enchant System Implementation

```go
// mystic/enchant.go
package mystic

import (
    "warlock-sim/core"
    "warlock-sim/warlock"
)

type EnchantRegistry struct {
    enchants map[string]Enchant
}

type Enchant interface {
    ID() string
    Apply(*warlock.Warlock)
}

var Registry = &EnchantRegistry{
    enchants: make(map[string]Enchant),
}

func (r *EnchantRegistry) Register(e Enchant) {
    r.enchants[e.ID()] = e
}

func (r *EnchantRegistry) Get(id string) Enchant {
    return r.enchants[id]
}

func init() {
    Registry.Register(&BackdraftChaosEnchant{})
    Registry.Register(&ImmolateHasteEnchant{})
    Registry.Register(&ConflagNoConsumeEnchant{})
}
```

```go
// mystic/backdraft_chaos.go
package mystic

import (
    "time"
    "warlock-sim/core"
    "warlock-sim/warlock"
)

type BackdraftChaosEnchant struct{}

func (e *BackdraftChaosEnchant) ID() string {
    return "backdraft_chaos_bolt"
}

func (e *BackdraftChaosEnchant) Apply(lock *warlock.Warlock) {
    // Create the preservation aura
    preservationAura := lock.RegisterAura(core.Aura{
        Label:    "Backdraft Preservation",
        ActionID: core.ActionID{SpellID: 99999},
        Duration: time.Second * 4,
    })
    
    // Hook into Chaos Bolt OnCast
    originalOnCast := lock.ChaosBolt.OnCastComplete
    
    lock.ChaosBolt.OnCastComplete = func(aura *core.Aura, sim *core.Simulation, spell *core.Spell) {
        // Check if Backdraft is active
        backdraftAura := lock.GetAura("Backdraft")
        if backdraftAura != nil && backdraftAura.IsActive() {
            // Activate preservation
            preservationAura.Activate(sim)
        }
        
        // Call original handler
        if originalOnCast != nil {
            originalOnCast(aura, sim, spell)
        }
    }
    
    // Modify Backdraft to not consume during preservation
    backdraftAura := lock.GetAura("Backdraft")
    originalOnSpellHit := backdraftAura.OnSpellHitDealt
    
    backdraftAura.OnSpellHitDealt = func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
        // If preservation is active, don't remove stacks
        if preservationAura.IsActive() {
            return
        }
        
        // Otherwise, call original (removes stack)
        if originalOnSpellHit != nil {
            originalOnSpellHit(aura, sim, spell, result)
        }
    }
}
```

```go
// mystic/immolate_haste.go
package mystic

import (
    "warlock-sim/warlock"
)

type ImmolateHasteEnchant struct{}

func (e *ImmolateHasteEnchant) ID() string {
    return "immolate_haste_scaling"
}

func (e *ImmolateHasteEnchant) Apply(lock *warlock.Warlock) {
    // Modify Immolate's DOT config
    immolate := lock.Immolate
    
    // Enable haste scaling on DOT
    immolate.Dot.TickLength = func(sim *core.Simulation) time.Duration {
        baseTickLength := time.Second * 3
        hasteMultiplier := lock.SpellHasteMultiplier()
        return time.Duration(float64(baseTickLength) / hasteMultiplier)
    }
}
```

#### 4.3: Loading Enchants

```go
// main.go (updated)
func main() {
    // ... load character config
    
    // Apply mystic enchants
    for _, enchantID := range charCfg.MysticEnchants {
        enchant := mystic.Registry.Get(enchantID)
        if enchant == nil {
            log.Printf("Warning: Unknown mystic enchant '%s'", enchantID)
            continue
        }
        enchant.Apply(warlock)
    }
    
    // ... run sim
}
```

#### Deliverable:
Fully working custom enchant system with 3-5 example enchants

---

## Project Structure

```
warlock-sim/
├── main.go                       # Entry point
├── go.mod
├── go.sum
├── README.md
│
├── config/                       # User configuration files
│   ├── character.yml             # Character stats, talents, gear
│   ├── rotation.yml              # APL in human-readable format
│   ├── spells.yml                # Spell database
│   └── mystic_enchants.yml       # Custom enchant definitions
│
├── proto/                        # Vendored protobuf files (Option 2)
│   ├── api.pb.go
│   ├── apl.pb.go
│   ├── common.pb.go
│   └── warlock.pb.go
│
├── core/                         # Core simulation engine (from WoWSims)
│   ├── sim.go                    # Main simulation loop
│   ├── spell.go                  # Spell system
│   ├── character.go              # Character/Unit base
│   ├── aura.go                   # Buff/debuff system
│   ├── dot.go                    # DOT mechanics
│   ├── stats.go                  # Stat system
│   ├── pending_action.go         # Event queue
│   ├── unit.go                   # Unit interface
│   └── environment.go            # Raid environment
│
├── warlock/                      # Warlock-specific code
│   ├── warlock.go                # Main Warlock struct
│   ├── talents.go                # Talent calculations
│   ├── chaos_bolt.go             # Chaos Bolt spell
│   ├── immolate.go               # Immolate spell
│   ├── conflagrate.go            # Conflagrate spell
│   ├── incinerate.go             # Incinerate spell
│   ├── corruption.go             # Corruption spell
│   ├── life_tap.go               # Life Tap
│   ├── backdraft.go              # Backdraft aura
│   └── rotation.go               # Rotation logic (if not using APL)
│
├── apl/                          # APL compiler
│   ├── compiler.go               # YAML → Proto converter
│   ├── parser.go                 # YAML parser
│   └── conditions.go             # Condition parsing
│
├── mystic/                       # Custom enchant system
│   ├── enchant.go                # Enchant interface & registry
│   ├── backdraft_chaos.go        # Backdraft + Chaos Bolt enchant
│   ├── immolate_haste.go         # Immolate haste scaling
│   └── conflag_no_consume.go     # Conflagrate doesn't consume
│
├── loader/                       # Configuration loaders
│   ├── character.go              # Load character.yml
│   ├── spells.go                 # Load spells.yml
│   ├── rotation.go               # Load rotation.yml
│   └── enchants.go               # Load mystic_enchants.yml
│
└── output/                       # Results output
    ├── formatter.go              # Format results
    └── exporter.go               # Export to JSON/CSV
```

---

## Usage Examples

### Basic Usage

```bash
# Install dependencies
go mod download

# Run with default configs
go run main.go

# Specify custom configs
go run main.go \
  --character config/my_char.yml \
  --rotation config/destro_aoe.yml \
  --iterations 50000

# Output results to JSON
go run main.go --output results.json
```

### Sample Output

```
═══════════════════════════════════════════════════════
           Warlock Simulation Results
═══════════════════════════════════════════════════════
Character: MyWarlock (Destruction)
Encounter: 300.0s (5:00)
Iterations: 10,000

───────────────────────────────────────────────────────
DPS: 8,432.5 ± 142.3
Total Damage: 2,529,750
───────────────────────────────────────────────────────

Spell Breakdown:
┌────────────────────┬─────────┬─────────┬──────────┐
│ Spell              │ Damage  │ % Total │ Casts    │
├────────────────────┼─────────┼─────────┼──────────┤
│ Chaos Bolt         │ 1,062k  │  42.0%  │   142    │
│ Immolate (DOT)     │   551k  │  21.8%  │    34    │
│ Immolate (Direct)  │   105k  │   4.2%  │    34    │
│ Conflagrate        │   474k  │  18.7%  │    67    │
│ Incinerate         │   338k  │  13.3%  │    89    │
├────────────────────┼─────────┼─────────┼──────────┤
│ Total              │ 2,530k  │ 100.0%  │   366    │
└────────────────────┴─────────┴─────────┴──────────┘

Aura Uptime:
  Backdraft: 82.4%
  Immolate: 98.7%

Cast Efficiency:
  Chaos Bolt: 96.2% (4 casts failed)
  GCD Utilization: 94.3%

Mana Usage:
  Starting: 20,000
  Ending: 3,245 (16.2%)
  Life Tap casts: 7
```

---

## Risk Analysis & Mitigation

### Major Risks:

1. **Proto Complexity**
   - **Risk:** Getting stuck on protobuf setup
   - **Mitigation:** Use Option 2 (vendor the .pb.go files)
   
2. **Spell Interactions**
   - **Risk:** Complex interactions between spells/auras
   - **Mitigation:** Start with simple spells, add complexity incrementally
   
3. **APL Bugs**
   - **Risk:** Compiled APL doesn't match YAML intent
   - **Mitigation:** Add verbose logging mode, unit tests for compiler
   
4. **Mystic Enchant Edge Cases**
   - **Risk:** Enchants breaking core mechanics
   - **Mitigation:** Each enchant is isolated, easy to disable for debugging

### Minor Risks:

5. **Performance**
   - **Risk:** Slow simulation
   - **Mitigation:** WoWSims engine is already optimized, should be fine
   
6. **YAML Parsing Errors**
   - **Risk:** User config errors crash sim
   - **Mitigation:** Validate configs on load, provide helpful error messages

---

## Success Criteria

### Phase 1 Success:
- ✅ Sim runs without crashing
- ✅ Outputs DPS number
- ✅ 3+ spells cast in rotation
- ✅ Results are reasonable (3000-4000 DPS range)

### Phase 2 Success:
- ✅ Character stats loaded from YAML
- ✅ Talents affect spell damage
- ✅ Can change gear and see DPS change

### Phase 3 Success:
- ✅ Write rotation in YAML
- ✅ APL compiles without errors
- ✅ Rotation executes correctly
- ✅ Conditions work (aura checks, cooldowns, etc.)

### Phase 4 Success:
- ✅ 3+ mystic enchants working
- ✅ Enchants modify spell behavior correctly
- ✅ Can enable/disable enchants in config

---

## Next Steps

### Immediate (This Week):
1. Clone WoWSims repository
2. Copy core engine files
3. Vendor proto files (Option 2)
4. Implement 1-2 simple spells
5. Get first DPS output

### Short Term (Week 2-3):
6. Add YAML character config
7. Implement 5-10 Warlock spells
8. Create YAML APL compiler
9. Test with simple rotations

### Medium Term (Week 4+):
10. Implement mystic enchant system
11. Add 5+ custom enchants
12. Polish output formatting
13. Add result export (JSON/CSV)

### Future Enhancements:
- Multi-target support
- Snapshot mechanics (pandemic, etc.)
- Advanced stat weights
- Optimization suggestions
- Web UI (if desired later)

---

## Resources & References

- **WoWSims GitHub:** https://github.com/wowsims/wotlk
- **Go Modules:** https://go.dev/doc/modules/managing-dependencies
- **YAML v3:** https://github.com/go-yaml/yaml
- **Protocol Buffers:** https://protobuf.dev/

---

## Appendix: File Copying Checklist

### Files to Copy from WoWSims:

**Core Engine (Essential):**
- [ ] `sim/core/sim.go`
- [ ] `sim/core/spell.go`
- [ ] `sim/core/character.go`
- [ ] `sim/core/unit.go`
- [ ] `sim/core/aura.go`
- [ ] `sim/core/dot.go`
- [ ] `sim/core/stats.go`
- [ ] `sim/core/pending_action.go`
- [ ] `sim/core/environment.go`
- [ ] `sim/core/cast.go`

**APL System:**
- [ ] `sim/core/apl.go`
- [ ] `sim/core/apl_action.go`
- [ ] `sim/core/apl_actions_*.go` (all action files)
- [ ] `sim/core/apl_value.go`
- [ ] `sim/core/apl_values_*.go` (all value files)

**Proto Files (Option 2 - Vendored):**
- [ ] `sim/core/proto/api.pb.go`
- [ ] `sim/core/proto/apl.pb.go`
- [ ] `sim/core/proto/common.pb.go`
- [ ] `sim/core/proto/warlock.pb.go` (if exists)

**Warlock Specific (Optional - for reference):**
- [ ] `sim/warlock/warlock.go`
- [ ] `sim/warlock/*.go` (individual spell files)

---

**Document Version:** 1.0  
**Last Updated:** November 2025  
**Status:** Draft - Ready for Implementation
